Head.Start=rep(0, 16),
Head.End=rep(20000, 16),
Tail.Start=chromosome_lengths$len - 20000,
Tail.End=chromosome_lengths$len
)
head(SubtelomericRegions)
# Found it. The same chromosomes pages on SGD mention the length.
# See creation of chromosome_lengths dataframe.
# Inner join with SubtelomericRegions
merged_subtelomeric <- merged_data %>%
inner_join(SubtelomericRegions, by = c("chromosome" = "Chromosome"))
# Filter for genes within the specified ranges
filter_subtel_head <- merged_subtelomeric %>%
filter((start >= Head.Start & end <= Head.End))
filter_subtel_tail <- merged_subtelomeric %>%
filter(start >= Tail.Start & end <= Tail.End)
filtered_data_subtelomeric <- rbind(filter_subtel_head, filter_subtel_tail)
# Extract unique non-empty Gene_Name values
Genes_in_Subtelomeric <- unique(filtered_data_subtelomeric$Gene_Name)
GenesinSub.noempty <- subset(Genes_in_Subtelomeric, Genes_in_Subtelomeric != "" & Genes_in_Subtelomeric != "NA")
# Write the results to a file
write.table(GenesinSub.noempty, file = 'Genes-in-SubtelomericRegions.txt')
# Print the length of the result
length(GenesinSub.noempty)
# i.e. 50k less than start, 50k more than end of rDNA locus
window_size2=50000
RibosomalRegions = data.frame(Chromosome=rep('chrXII',2),
Region=c('RDN18-1','RDN18-2'),
Ribostart=c(455933-window_size2,465070-window_size2),
Riboend=c(457732+window_size2,466869+window_size2)
)
RibosomalRegions
## Attempt 2. No joins needed since we're only looking at values in one chromo
## Simply filter out matching three conditions for first region, and second region
## then, combine together
filtered_data_ribo_1 <- merged_data %>%
filter(
chromosome == 'chrXII',
start >= RibosomalRegions$Ribostart[1],
end <= RibosomalRegions$Riboend[1]
)
filtered_data_ribo_2 <- merged_data %>%
filter(
chromosome == 'chrXII',
start >= RibosomalRegions$Ribostart[2],
end <= RibosomalRegions$Riboend[2]
)
filtered_data_ribo.combined <- rbind(filtered_data_ribo_1, filtered_data_ribo_2)
GenesinRibo <- unique(filtered_data_ribo.combined$Gene_Name)
GenesinRibo.noempty <- subset(GenesinRibo, GenesinRibo != "" & GenesinRibo != "NA")
write.table(GenesinRibo.noempty, file = 'Genes-in-RibosomalRegions.txt')
length(GenesinRibo.noempty)
Genesin3Regions=unique(c(GenesinPeri.noempty,
GenesinSub.noempty,
GenesinRibo.noempty))
length(Genesin3Regions)
write.table(Genesin3Regions,file='Genesin3Regions.txt')
## REMINDER: pipeline was merged --> filtered.
# filtered is the one that actually contains those within the regions.
# filtered_data_peri$count
# filtered_data_subtelomeric$count
# filtered_data_ribo.combined$count
# Upon loading v2 of the alignments, which had -type gene argument in ht-seq,
# There are finally things with gene names that have actual counts!
# On top of that, only the ones with names have counts.
## Testing below. Unique count amounts for those with Names, and those without.
# unique((merged_data[merged_data$Gene_Name!="",])$count)
# The ones with names mostly have counts.
# unique((merged_data[merged_data$Gene_Name=="",])$count)
# The ones without names do not have counts. Can ignore these subfeatures.
# Goal: Group the datasets based on gene. Or for each gene, iterate through all the non-NA, non-empty counts and add them to a vector, then calculate the average of them. Add this to a growing column in a dataframe. I should have in the dataframe a column of all the genes. i.e. column Genes=Genesin3Regions and column avgexplvl for all the average counts for each gene.
# Need to find a way to make an iterable way (for gene in Genesin3Regions) to filter all the merged data (because we need to search from ALL across the regions. Non-region ones will also search here as the filtering options will take care of it.) for all rows that match that Gene_Name.
# Genesin3Regions
# For genes in Genesin3regions... something something grab the row whose Gene_Name matches it
G3Rcounts <- numeric(length(Genesin3Regions))  # Initialize a numeric vector to store counts
# Loop through each gene in Genesin3Regions
for (i in seq_along(Genesin3Regions)) {
# Subset merged_data to rows where Gene_Name matches the current gene
gene_subset <- merged_data[merged_data$Gene_Name == Genesin3Regions[i], ]
# Check if any rows were found for the current gene
if (nrow(gene_subset) > 0) {
# If rows were found, extract the count value (assuming count is numeric)
G3Rcounts[i] <- gene_subset$count[1]  # Assuming there's only one count per gene
} else {
# If no rows were found, set count to NA
G3Rcounts[i] <- NA
}
}
G3Rcounts
## These are the expression levels for all the genes. I can calculate the average of all of these by filtering merged_genes dataframe for all the rows whose $count matches G3Rcounts. (filtered_data_G3R)
merged_data=merged_data[, !(names(merged_data) == "count")]
## Remove count. That was not correct, but everything else is.
## The actual counts are in MappedTimePoints below.
## NOTE ALSO: 01 is technically not part of the time course. So use 02 to 12. ##
# I notice the same gene ID's are present acros all the 12 separate counts.
# I should map the gene ID's from each one into like a dataframe
# say, gene ID SK1...010 should have its $count from 02, 03, ... 12 mapped on a dataframe whose columns read A, B, D, E, F, G, I (first), K, L, O, V.
# rows will be populated by gene ID's
# the rownames for all count_data and the count_data 01 to 12 are all equivalent
# I think the countdatas 01 to 12 were what I was supposed to do all along.
# Can I cbind them.. YES!!! This is what I was looking for all along.
# rownames(count_data)
MappedTimePoints=cbind(count_data_02,count_data_03,count_data_04,count_data_05,
count_data_06,count_data_07,count_data_08,count_data_09,
count_data_10,count_data_11,count_data_12)
colnames(MappedTimePoints)=c('A','B','D','E','F','G','I (first)','K','L','O','V')
head(MappedTimePoints)
## MappedTimePoints, are the expressions for each ID across each of the time points.
## Now, for avg GENE exp, I need to group together ID's based on their gene.
# Custom function NormalizerV2:
# Version 2: inputvector = vector for which all values you'd like to be normalized
# 0th step: create empty vector to add into.
# First, take mean and sd of the column, save as variables.
# Second, for loop --> For each value inside, subtract it from mean and sd (calculated earlier)
# Save these in the empty vector. This will be added to the dataframe outside of the function.
NormalizerV2 = function(inputvector) {
normalized_column=numeric(0)
mean_column = mean(inputvector)
sd_column = sd(inputvector)
for (y in 1:length(inputvector)) {  #y is the position in the column.
normalized_value = (inputvector[y] - mean_column) / sd_column
normalized_column[y] = normalized_value
}
normalized_column
}
MappedTimePoints.normalized=as.data.frame(t(apply(MappedTimePoints, MARGIN=1, NormalizerV2)))
colnames(MappedTimePoints.normalized)=c('A','B','D','E','F','G','I (first)','K','L','O','V')
# margin=1 for applying to rows instead of columns.
# because we want to treat each row as its own vector (as they should represent one gene ID, and later on one gene name)
# With this normalization, huge outliers will be a bit easier to see. Most values will now be in a range of -1 to 1.
head(MappedTimePoints.normalized)
## Relating the Gene Name to the timepoints so we can order based on gene later
# and calculate the avg gene exp for all rows under the same Gene_Name
# Add a new column 'Gene_Name' to MappedTimePoints.normalized
MappedTimePoints.normalized$Gene_Name=NA
# Iterate over each row of MappedTimePoints
for (row in 1:nrow(MappedTimePoints.normalized)) {
# Get the row name
row_name=rownames(MappedTimePoints.normalized)[row]
# Find the index in merged_data$Mapped_Gene_ID that matches the row name
id.index=which(merged_data$Mapped_Gene_ID == row_name)[1]
# If id.index exists, assign the corresponding Gene_Name to MappedTimePoints.normalized
if (!is.na(id.index)) {
MappedTimePoints.normalized$Gene_Name[row] <- merged_data$Gene_Name[id.index]
}
}
MappedTimePoints.clean=
MappedTimePoints.normalized[which(MappedTimePoints.normalized$Gene_Name!='NA'),]
# which(MappedTimePoints.clean$Gene_Name=='NA')
#Discarded all gene ID's with no name
head(MappedTimePoints.clean)
## Ordering MappedTimePoints.clean based on Gene_Name
## Note: Ordering rows based on Gene_Name alphabetically will naturally keep
# those with the same gene name together (i.e. under the same gene)
MappedTimePoints.ordered=arrange(MappedTimePoints.clean,Gene_Name)
head(MappedTimePoints.ordered)
MappedTimePoints.ordered=group_by(MappedTimePoints.ordered,Gene_Name)
# Updated the same dataframe. Now it has grouping.
# after organizing, group together the same Gene_Name ones so I can apply
# further functions to each group instead.
dim(MappedTimePoints.ordered)
# medianByGroup <- MappedTimePoints.ordered %>%
#   group_by(Gene_Name) %>%
#   summarize(across(.cols = c(1:11), .fns = median, na.rm = TRUE)) %>%
#   ungroup()
#
# # Find genes whose median is greater than or equal to 10
# genesToRemove <- medianByGroup %>%
#   filter(rowSums(select(., -Gene_Name) < 10) > 0) %>%
#   pull(Gene_Name)
#
# # Remove genes whose median is less than 10
# MappedTimePoints.orderedFiltered <- MappedTimePoints.ordered %>%
#   filter(!Gene_Name %in% genesToRemove)
#
# dim(MappedTimePoints.orderedFiltered)
# summarize(MappedTimePoints.ordered,across(.cols = c(1:11), .fns = mean, na.rm = TRUE))
# across is deprecated, I was suggested to use an anonymous func instead
AVGEXPLVL.ALL=summarize(MappedTimePoints.ordered,across(.cols = c(1:11),
.fns = \(x) mean(x, na.rm = TRUE)))
head(AVGEXPLVL.ALL)
# This is for ALL genes. So we should filter out for Gene_Names that fit within the three regions (Genesin3Regions)...
#and for those that do not fit within the 3 regions (the opposite)
# Let's use the 3 regions gene list we made earlier.
# I need to find all the rows in AVGEXPLVL.ALL that match Genesin3Regions
# note: 1st %in% 2nd. looking for things in 1st that are in 2nd
AVGEXPLVL.3Regions=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% Genesin3Regions,]
# AVGEXPLVL.3Regions.df=as.data.frame(AVGEXPLVL.3Regions)
# rownames(AVGEXPLVL.3Regions.df)=AVGEXPLVL.3Regions$Gene_Name
# AVGEXPLVL.3Regions.df=AVGEXPLVL.3Regions.df[, -1]
#   # made it a dataframe, changed the first column (Gene_Name) to be rownames
head(AVGEXPLVL.3Regions)
write.csv(AVGEXPLVL.3Regions,file='AvgExpLevel.3Regions.csv')
AVGEXPLVL.Ctrl=AVGEXPLVL.ALL[!(AVGEXPLVL.ALL$Gene_Name %in% Genesin3Regions),]
# negated the %in% pattern searching. so this is just the inverse
# AVGEXPLVL.Ctrl.df=as.data.frame(AVGEXPLVL.Ctrl)
# rownames(AVGEXPLVL.Ctrl.df)=AVGEXPLVL.Ctrl$Gene_Name
# AVGEXPLVL.Ctrl.df=AVGEXPLVL.Ctrl.df[, -1]
head(AVGEXPLVL.Ctrl)
write.csv(AVGEXPLVL.Ctrl,file='AvgExpLevel.Control.csv')
AEL.3R.long=tidyr::pivot_longer(AVGEXPLVL.3Regions,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
Violin3Regions = ggplot(AEL.3R.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Peri, Subtelo, Ribo Regions") +
theme_light()
Violin3Regions
# ggsave("Violin3Regions.png", plot = Violin3Regions,
#        width = 1280, height = 960,
#        units = "px")
AEL.Ctrl.long=tidyr::pivot_longer(AVGEXPLVL.Ctrl,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinControl = ggplot(AEL.Ctrl.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.017) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinControl
# ggsave("ViolinControl.png", plot = ViolinControl,
#        width = 6, height = 4, units = "in")
AVGEXPLVL.3Regions
Genesin3Regions
GenesinPeri
Genes_in_Subtelomeric
GenesinRibo
filtered_data_peri
class(filtered_data_peri)
View(filtered_data_peri)
View(AVGEXLLVL.ALL)
View(AVGEXPLVL.ALL)
view(AVGEXPLVL.3Regions)
MappedTimePoints.normalized
View(MappedTimePoints.ordered)
GenesinPeri.noempty
AVGEXPLVL.Peri=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% GenesinPeri.noempty,]
AVGEXPLVL.Peri
AVGEXPLVL.Sub=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% Genes_in_Subtelomeric,]
AVGEXPLVL.Peri=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% GenesinPeri.noempty,]
AVGEXPLVL.Sub=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% Genes_in_Subtelomeric,]
AVGEXPLVL.Ribo=AVGEXPLVL.ALL[AVGEXPLVL.ALL$Gene_Name %in% GenesinRibo.noempty,]
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.017) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinPeri
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.01) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinPeri
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.5) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinPeri
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.03) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinPeri
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinPeri
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Pericentromeric region") +
theme_light()
ViolinPeri
AEL.Sub.long=tidyr::pivot_longer(AVGEXPLVL.Sub,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinSub = ggplot(AEL.Sub.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Pericentromeric region") +
theme_light()
ViolinSub
AEL.Ribo.long=tidyr::pivot_longer(AVGEXPLVL.Ribo,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinRibo = ggplot(AEL.Ribo.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Pericentromeric region") +
theme_light()
ViolinRibo
AEL.Sub.long=tidyr::pivot_longer(AVGEXPLVL.Sub,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinSub = ggplot(AEL.Sub.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Subtelomeric region") +
theme_light()
ViolinSub
AEL.Ribo.long=tidyr::pivot_longer(AVGEXPLVL.Ribo,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinRibo = ggplot(AEL.Ribo.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Ribosomal region") +
theme_light()
ViolinRibo
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.07) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Pericentromeric region") +
theme_light()
ViolinPeri
AEL.Sub.long=tidyr::pivot_longer(AVGEXPLVL.Sub,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinSub = ggplot(AEL.Sub.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.07) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Subtelomeric region") +
theme_light()
ViolinSub
AEL.Ribo.long=tidyr::pivot_longer(AVGEXPLVL.Ribo,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinRibo = ggplot(AEL.Ribo.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.07) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Ribosomal region") +
theme_light()
ViolinRibo
AEL.Ribo.long=tidyr::pivot_longer(AVGEXPLVL.Ribo,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinRibo = ggplot(AEL.Ribo.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Ribosomal region") +
theme_light()
ViolinRibo
AEL.Sub.long=tidyr::pivot_longer(AVGEXPLVL.Sub,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinSub = ggplot(AEL.Sub.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Subtelomeric region") +
theme_light()
ViolinSub
AEL.Peri.long=tidyr::pivot_longer(AVGEXPLVL.Peri,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
ViolinPeri = ggplot(AEL.Peri.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Pericentromeric region") +
theme_light()
ViolinPeri
AEL.Ctrl.long=tidyr::pivot_longer(AVGEXPLVL.Ctrl,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinControl = ggplot(AEL.Ctrl.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.05) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinControl
# ggsave("ViolinControl.png", plot = ViolinControl,
#        width = 6, height = 4, units = "in")
AEL.Ctrl.long=tidyr::pivot_longer(AVGEXPLVL.Ctrl,
cols = -Gene_Name,
names_to = 'Time_Point',
values_to='Expression_Level')
# doesn't pivot the gene name.
ViolinControl = ggplot(AEL.Ctrl.long, aes(x = Time_Point, y = Expression_Level, fill = as.factor(Time_Point))) +
geom_dotplot(binaxis = "y", stackdir = "center", binwidth = 0.017) +
theme_minimal() +
labs(x = "Time Point", y = "Expression Level") +
scale_fill_discrete(name = "Time Point") +
ggtitle("Avg Gene Exp Over Time: Control Group") +
theme_light()
ViolinControl
# ggsave("ViolinControl.png", plot = ViolinControl,
#        width = 6, height = 4, units = "in")
rstudioapi::getSourceEditorContext()$path
list.files('./DDS-readcounts',full.names=T)
getwd()
View(count_data)
View(count_data)
GFFAnno$attributes
?help
?help list.files
DSSfilelist
R.version.string
?read.table
Gene_ID
GFFAnno$attributes
Gene_ID
Gene_Name
Gene_ID
Gene_ID
Gene_Name
GFFAnno$attributes
GFFAnno$attributes
GenesPresentAlphabetical
class(GenesPresentAlphabetical)
length(GenesPresentAlphabetical)
Gene_Name.noempty
class(Gene_Name)
GenesPresentAlphabetical
length(GenesPresentAlphabetical)
head(GFFAnno$attributes)
tail(GFFAnno$attributes)
write.table(GFFAnno$attributes,file=)
write.table(GFFAnno$attributes,file='GFFAttributes.txt')
DSSfilelist
?sprintf
